useCallback은 함수를 기억한다. 의존성을 생략하면  함수가 기억할 때의 참조값들이 고정된다
useEffect는 콜백을 재실행할 조건을 지정한다. 의존성을 생략하면 매렌더링마다  실행
- API 호출의 경우 무한 실행된다(함수 실행 -> 상태 업데이트 -> 재렌더링 -> useEffect -> 무한 루프)


useCallback : 함수 고정
useMemo : 계산된 값(객체, 배열)을 고정
React.memo : props가 변경되지 않은 경우 재렌더링 방지





왜 useMemo에서 check를 의존성에 추가해야 할까?
문제 시나리오:
useCallback은 value가 변할 때마다 새로운 check 함수를 생성합니다.

javascript
const check = useCallback(() => { 
  console.log(value); // ✅ 최신 value 참조
}, [value]); // value가 바뀌면 check 함수 재생성
하지만 useMemo에서 check를 의존성 배열에서 빼면?

javascript
useMemo(() => ({ check }), []); // ❌ check 누락
→ check 함수가 새로 생성되어도 useMemo는 이전 객체를 계속 반환합니다.
→ 객체 안의 check는 최신 함수가 아닌 옛날 함수를 참조하게 됩니다!

결과:
버그: check 함수는 최신 value를 보지 못하고, 렌더링 초기의 value를 계속 참조합니다.

